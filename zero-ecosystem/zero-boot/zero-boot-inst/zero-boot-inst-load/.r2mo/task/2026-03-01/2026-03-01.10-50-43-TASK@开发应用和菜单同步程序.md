---
runAt: 2026-02-28.20-18-10
title: 开发应用和菜单同步程序
status: completed
---

## 任务概述

实现 `io.zerows.boot.inst.LoadInst` 核心逻辑，从多模块的 `apps/` 目录加载 `X_APP` 和 `X_MENU` 数据并同步到数据库。

## 输入规范

**数据源**：
- 多模块 `src/main/resources/apps/` 目录
- `apps/{UUID}.yml` - 应用配置文件
- `apps/{UUID}/nav/` - 菜单目录结构

**命名规则**：
- 目录：`{order}@{text}` 或 `TYPE@{type}`
- 文件：`{order}_{text}.yml`
- 特殊文件：`MENU.yml` 表示目录本身是菜单

**配置加载**：
- 全局配置：`init/environment.json` 的 `global` 节点
- 环境变量：`{{ VAR }}` 格式，使用 `Ut.compileAnsible()` 处理

## 核心规则

**应用 ID 规则**：
- HOME 目录：使用全局配置的 `appId`
- 其他目录：使用目录名（UUID）

**菜单类型规则**：
- `TYPE@XXX` 目录：该目录下菜单 type 为 `XXX`
- 普通目录：默认 type 为 `SIDE-MENU`
- 不继承父目录的 type

**唯一性约束**：
- XApp：按 `ID` 判重
- XMenu：按 `NAME + APP_ID` 判重

## 输出规范

**数据库操作**：
- Upsert 到 `X_APP` 和 `X_MENU` 表
- 统计新增/更新数量

**YAML 缓存**：
- 路径：`$R2MO_HOME/apps/{UUID}/menu.yml`（未配置则使用 `./apps/`）
- 格式：标准 YAML，包含完整菜单树和 UUID

---

## 实现架构

### 核心类设计

| 类名 | 职责 | 关键方法 |
|------|------|----------|
| `LoadInst` | 启动器 | `runLoad()` 调用 BuildApp |
| `BuildApp` | 流程编排 | 加载配置、扫描文件、协调 Loader/Persister |
| `BuildMenuLoader` | 文件加载 | YAML 解析、反序列化、字段填充 |
| `BuildMenuPersister` | 数据持久化 | Upsert、YAML 缓存生成 |

### 职责分离原则

```
LoadInst (启动)
    ↓
BuildApp (编排)
    ↓
BuildMenuLoader (加载) → BuildMenuPersister (持久化)
```

---

## 核心功能实现

### 1. 文件加载（BuildMenuLoader）

**应用加载**：
```java
// 从 apps/{UUID}.yml 加载
final JsonObject appData = Ut.ioYaml(appFile.getAbsolutePath());
final XApp app = Ut.deserialize(appData, XApp.class);

// 填充全局字段
this.fillAuditFields(app, globalConfig, XApp::setCreatedAt, ...);
```

**菜单加载**：
```java
// 递归扫描 nav/ 目录
private List<XMenu> loadMenusRecursive(
    File navRoot,           // nav 根目录（用于计算相对路径）
    File dir,               // 当前目录
    String appId,           // 应用 ID
    String parentId,        // 父菜单 ID
    int level,              // 层级
    List<XMenu> result      // 结果集
)
```

**关键逻辑**：
- 使用 `menuUuidCache` 缓存菜单 UUID（按 `appId:name`）
- 使用 `dirPathToMenuId` 缓存目录到菜单 ID 的映射（支持跨模块）
- 相对路径计算：从 `nav` 目录开始，避免绝对路径问题

**审计字段填充**：
```java
private <T> void fillAuditFields(
    T entity,
    JsonObject globalConfig,
    BiConsumer<T, LocalDateTime> setCreatedAt,
    BiConsumer<T, String> setCreatedBy,
    ...
) {
    // 使用函数式接口消除 XApp 和 XMenu 的重复代码
}
```

### 2. 数据持久化（BuildMenuPersister）

**Upsert 逻辑**：
```java
// XApp 按 ID 判重
DB.on(XAppDao.class).fetchByIdAsync(app.getId())
    .compose(existing -> {
        if (existing == null) {
            return insertAsync(app).map(r -> "insert");
        } else {
            return updateAsync(app).map(r -> "update");
        }
    });

// XMenu 按 NAME+APP_ID 判重
DB.on(XMenuDao.class).fetchAsync()
    .map(list -> list.stream()
        .filter(m -> m.getName().equals(menu.getName())
                  && m.getAppId().equals(menu.getAppId()))
        .findFirst()
        .orElse(null))
    .compose(existing -> { ... });
```

**ID 一致性处理**：
```java
if (!menu.getId().equals(existing.getId())) {
    // ID 变化，删除旧记录再插入新记录（保持缓存一致性）
    return deleteByIdAsync(existing.getId())
        .compose(deleted -> insertAsync(menu).map(r -> "update"));
} else {
    // ID 相同，直接更新
    return updateAsync(menu).map(r -> "update");
}
```

**统计优化**：
```java
// 返回 [新增数, 更新数]
Future<int[]> persistMenus(List<XMenu> menus) {
    int[] stats = {0, 0};
    // 根据 upsert 返回值统计
    if ("insert".equals(result)) stats[0]++;
    if ("update".equals(result)) stats[1]++;
    return Future.succeededFuture(stats);
}
```

**YAML 缓存生成**：
```java
// 序列化为 JSON
final String jsonStr = Ut.serializeJson(menu);
final JsonObject json = new JsonObject(jsonStr);

// 转换为 YAML
final YAMLMapper yamlMapper = new YAMLMapper();
final String yaml = yamlMapper.writeValueAsString(json.getMap());

// 写入文件
final String cachePath = cacheDir + "/" + appId + "/menu.yml";
Files.write(Paths.get(cachePath), yaml.getBytes(StandardCharsets.UTF_8));
```

### 3. 配置管理（BuildApp）

**全局配置加载**：
```java
// 加载 environment.json
final JsonObject envConfig = ZeroFs.of(this.getClass())
    .readJson("init/environment.json");

// 处理环境变量替换
final JsonObject compiled = Ut.compileAnsible(envConfig);

// 提取 global 节点
final JsonObject globalConfig = compiled.getJsonObject("global");
```

**缓存目录解析**：
```java
final String r2moHome = System.getenv("R2MO_HOME");
final String cacheDir = (r2moHome != null && !r2moHome.isEmpty())
    ? r2moHome + "/apps"
    : "./apps";
LOGGER.info("使用缓存目录: {}", cacheDir);
```

---

## 关键技术点

### 1. 跨模块菜单合并

**问题**：不同模块可能有相同的父菜单（如 `80200@外部协同`）

**解决方案**：
- 使用相对路径作为缓存 key：`appId:relativePath`
- 相对路径从 `nav` 目录开始计算
- 不同模块的相同目录结构有相同的相对路径

```java
// 计算相对路径
private String getRelativePath(File navRoot, File dir) {
    final String navPath = navRoot.getAbsolutePath();
    final String dirPath = dir.getAbsolutePath();
    if (dirPath.startsWith(navPath)) {
        String relative = dirPath.substring(navPath.length());
        if (relative.startsWith("/") || relative.startsWith("\\")) {
            relative = relative.substring(1);
        }
        return relative;
    }
    return dir.getName();
}

// 缓存目录到菜单 ID
final String relativePath = this.getRelativePath(navRoot, dir);
final String dirKey = appId + ":" + relativePath;
this.dirPathToMenuId.put(dirKey, currentMenu.getId());
```

### 2. parentId 查找优先级

**问题**：缓存中的 ID 可能无效（菜单加载失败）

**解决方案**：
```java
if (currentMenu != null) {
    // 1. 当前目录有 MENU.yml，使用其 ID
    currentParentId = currentMenu.getId();
} else if (parentId == null) {
    // 2. 当前目录没有 MENU.yml，且传入的 parentId 为 null
    //    尝试从缓存中查找（支持跨模块）
    final String cachedId = this.dirPathToMenuId.get(dirKey);
    if (cachedId != null) {
        currentParentId = cachedId;
    }
}
// 3. 如果 parentId 不为 null，直接使用传入的值（来自上层递归）
```

**优先级**：上层递归传入的 parentId > 当前目录 MENU.yml > 缓存查找

### 3. level 计算规则

**规则**：
- 当前目录有 `MENU.yml`：子菜单 level = 当前 level + 1
- 当前目录没有 `MENU.yml`：子菜单 level = 当前 level（不增加层级）

```java
// 确定子菜单的 level
final int childLevel = currentMenu != null ? level + 1 : level;

// 递归处理子目录
this.loadMenusRecursive(navRoot, file, appId, currentParentId, childLevel, result);

// 处理菜单文件
final XMenu menu = this.loadMenuFromFile(file, appId, currentParentId, childLevel, ...);
```

**示例**：
```
nav/80200@外部协同/                    # level 1
├── MENU.yml (zero.cm)                # level 1, parent_id = null
├── 5000@客户管理/                     # 进入子目录，childLevel = 2
│   ├── MENU.yml (zero.cm.customer)   # level 2, parent_id = zero.cm
│   └── 1000_合作伙伴.yml              # level 3, parent_id = zero.cm.customer
└── TYPE@NAV-MENU/                    # 进入子目录，childLevel = 2
    └── 1000_外包入场_W.yml            # level 3, parent_id = zero.cm
```

### 4. 菜单类型（TYPE）规则

**规则**：
- 菜单的 `type` 只看菜单所在的目录
- 不继承父目录的 type

```java
// 提取目录中的 TYPE
private String extractTypeFromDirName(String dirName) {
    if (dirName.startsWith("TYPE@")) {
        return dirName.substring(5); // 去掉 "TYPE@" 前缀
    }
    return "SIDE-MENU"; // 默认类型
}

// 设置菜单类型
if (menu.getType() == null || menu.getType().isEmpty()) {
    final String dirName = parentDir.getName();
    final String menuType = this.extractTypeFromDirName(dirName);
    menu.setType(menuType);
}
```

**示例**：
```
apps/HOME/nav/
├── 10000@工作台/              # 此目录下菜单 type: SIDE-MENU (默认)
│   └── 1000_我的待办.yml      # type: SIDE-MENU
├── TYPE@TOP-MENU/            # 此目录下菜单 type: TOP-MENU
│   └── 10000_个人信息.yml     # type: TOP-MENU
└── TYPE@EXTRA-MENU/          # 此目录下菜单 type: EXTRA-MENU
    └── 10000_帮助.yml         # type: EXTRA-MENU
```

### 5. HOME 目录特殊处理

**规则**：
- HOME 目录的菜单 `appId` 使用全局配置的 `appId`
- 其他应用目录的菜单 `appId` 使用目录名（UUID）

```java
// HOME 目录使用全局配置的 appId，其他使用目录名
final String actualAppId = "HOME".equals(appId)
    ? this.globalConfig.getString("appId")
    : appId;
```

---

## 异步处理模式

**所有数据库操作返回 `Future<T>`**：
```java
// 组合异步流程
return DB.on(XAppDao.class).fetchByIdAsync(id)
    .compose(existing -> {
        if (existing == null) {
            return DB.on(XAppDao.class).insertAsync(app);
        } else {
            return DB.on(XAppDao.class).updateAsync(app);
        }
    })
    .map(result -> "success");

// 并发执行多个操作
Future.all(
    persistApp(app1),
    persistApp(app2),
    persistApp(app3)
).onSuccess(results -> {
    LOGGER.info("所有应用持久化完成");
});
```

---

## 日志规范

**日志级别**：
- `INFO`：统计信息、关键流程
- `DEBUG`：详细操作、文件路径

**统计格式**：
```
应用: 加载 5 / 新增 2 / 更新 3
菜单: 加载 120 / 新增 45 / 更新 75
使用缓存目录: /path/to/R2MO_HOME/apps
```

---

## 优化记录

| 优化项 | 优化前 | 优化后 | 收益 |
|--------|--------|--------|------|
| 类命名 | BuildAppMenuLoader | BuildMenuLoader | 更简洁 |
| 审计字段 | 重复 40 行 | 公共方法 25 行 | 减少 15 行 |
| 序列化 | 手动构造 10+ 字段 | Ut.serializeJson() | 减少 10 行 |
| 统计信息 | 总数 | 新增/更新 | 更详细 |
| YAML 输出 | JSON 格式 | 标准 YAML | 格式正确 |
| 缓存路径 | 固定当前目录 | 支持环境变量 | 灵活部署 |
| parentId 查找 | 绝对路径 | 相对路径 | 跨模块支持 |
| ID 一致性 | 覆盖 ID | 删除重插 | 避免无效引用 |

---

## 编译状态

✅ BUILD SUCCESS - 所有代码编译通过

---

## 测试清单

- [ ] 单模块应用和菜单加载
- [ ] 多模块跨模块父菜单合并
- [ ] HOME 目录特殊处理
- [ ] TYPE 目录菜单类型设置
- [ ] YAML 缓存文件生成
- [ ] 数据库 Upsert 逻辑
- [ ] 统计信息准确性
- [ ] 环境变量替换
- [ ] R2MO_HOME 缓存目录

---

## 关键 Bug 修复历史

### Bug 1: 绝对路径导致跨模块无法匹配

**问题**：使用绝对路径作为缓存 key，不同模块的相同目录无法匹配

**修复**：使用相对路径（从 `nav` 目录开始）

### Bug 2: parentId 指向不存在的记录

**问题**：从缓存查找的 parentId 对应的菜单可能加载失败

**修复**：优化查找优先级，只在 parentId 为 null 时才从缓存查找

### Bug 3: level 计算错误

**问题**：子文件的 level 计算不正确

**修复**：根据当前目录是否有 MENU.yml 决定子菜单 level

### Bug 4: ID 不一致导致 parentId 无效

**问题**：Loader 缓存的 ID 与数据库中的 ID 不一致

**修复**：如果 ID 变化，删除旧记录再插入新记录（保持缓存一致性）

---

## 参考资料

**模型定义**：
- `zero-exmodule-ambient-domain` - XApp/XMenu 数据结构

**工具类**：
- `Ut.deserialize()` - YAML 反序列化
- `Ut.serializeJson()` - JSON 序列化
- `Ut.compileAnsible()` - 环境变量替换
- `ZeroFs.of()` - 文件加载

**数据库访问**：
- `DB.on(XAppDao.class)` - XApp DAO
- `DB.on(XMenuDao.class)` - XMenu DAO
- `fetchByIdAsync()` - 按 ID 查询
- `fetchAsync()` - 查询所有
- `insertAsync()` - 插入
- `updateAsync()` - 更新
- `deleteByIdAsync()` - 删除
