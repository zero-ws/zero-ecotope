package io.zerows.epoch.bootplus.exploit.atom.mock;

import io.zerows.metadata.normalize.KMarkAttribute;
import io.zerows.metadata.reference.RReference;
import io.zerows.metadata.reference.RRule;
import io.zerows.constant.VString;
import io.zerows.enums.modeling.EmModel;
import io.zerows.specification.access.app.HArk;
import io.zerows.specification.modeling.HAtom;
import io.zerows.specification.modeling.HAttribute;
import io.zerows.specification.modeling.HModel;
import io.zerows.specification.modeling.HReference;
import io.zerows.specification.modeling.HRule;
import io.zerows.specification.modeling.metadata.HMetaAtom;
import io.zerows.specification.modeling.metadata.HMetaField;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;

import static io.zerows.epoch.bootplus.extension.refine.Ox.LOG;

/**
 * @author <a href="http://www.origin-x.cn">Lang</a>
 */
public class QReport {
    // Report for Uniform Data Structure `HAtom` Here
    public static void outAtom(final HAtom atom) {
        Objects.requireNonNull(atom);
        // Report for argument here
        final StringBuilder builder = new StringBuilder();

        final HModel model = atom.model();
        // Atom Basic Information
        final HArk ark = atom.ark();
        builder.append("「Atom」--------------------------------------------").append(VString.NEW_LINE);
        builder.append("identifier: ").append(atom.identifier()).append(VString.NEW_LINE);
        builder.append("sigma: ").append(ark.sigma()).append(VString.NEW_LINE);
        builder.append("language: ").append(ark.language()).append(VString.NEW_LINE);
        final HMetaAtom metaAtom = atom.shape();
        builder.append("Complex? ").append(metaAtom.isComplex()).append(VString.NEW_LINE);

        // Atom -> Model
        if (Objects.nonNull(model)) {
            builder.append("「Model」-------------------------------------------").append(VString.NEW_LINE);
            builder.append("namespace: ").append(model.namespace()).append(VString.NEW_LINE);
            builder.append("identifier: ").append(model.identifier()).append(" --> Matched: ")
                .append(atom.identifier().equals(model.identifier())).append(VString.NEW_LINE);
            // Atom -> HAttribute / HReference / HMarker
            final EmModel.Type type = model.type();
            builder.append("type: ").append(type).append(VString.NEW_LINE);
        }

        // Atom Unique Rule
        builder.append("「Unique Rule」---------------------------------------").append(VString.NEW_LINE);
        builder.append("Unique Rule: ");
        final HRule rule = atom.ruleAtom();
        if (Objects.nonNull(rule)) {
            builder.append(rule).append(VString.NEW_LINE);
        }
        builder.append("Channel Rule: ").append(VString.NEW_LINE);
        final HRule ruleChannel = atom.rule();
        if (Objects.nonNull(ruleChannel)) {
            builder.append(ruleChannel).append(VString.NEW_LINE);
        }
        builder.append("Smart Looking For: ").append(atom.ruleSmart()).append(VString.NEW_LINE);

        builder.append("「Attribute」---------------------------------------").append(VString.NEW_LINE);
        // Attribute Information
        final Set<String> attributes = atom.attribute();
        final HReference reference = atom.reference();
        final Set<String> treeSet = new TreeSet<>(attributes);
        treeSet.stream().filter(name -> Objects.nonNull(atom.attribute(name))).forEach(name -> {
            // Each Data for Attribute
            final HAttribute attribute = atom.attribute(name);
            final RReference refData;
            if (Objects.isNull(reference)) {
                refData = null;
            } else {
                refData = reference.refData(name);
            }
            builder.append(outAttribute(attribute, refData));
        });
        builder.append("Attribute Size = ").append(treeSet.size()).append(VString.NEW_LINE);
        // #NEW_LOG
        LOG.Atom.info(QReport.class, "\n" + builder);
    }

    private static String outAttribute(final HAttribute attribute, final RReference reference) {
        final StringBuilder builder = new StringBuilder();
        final HMetaField attr = attribute.field();

        final KMarkAttribute tag = attribute.marker();

        final RRule refRule = attribute.referenceRule();
        // Basic Line
        builder.append(":::" + VString.LEFT_BRACKET).append(attr.alias())
            .append(",").append(attr.name()).append(VString.RIGHT_BRACKET).append(VString.COMMA);
        builder.append(" type=").append(attr.type()).append(VString.COMMA);
        builder.append(" formatFail=").append(attribute.format()).append(VString.NEW_LINE);

        // Tag
        if (Objects.nonNull(tag)) {
            builder.append("\t").append(tag).append(VString.NEW_LINE);
        }

        // Complex Line
        if (Objects.nonNull(refRule)) {
            builder.append("\t").append(refRule).append(VString.NEW_LINE);
        }
        if (attr.isComplex()) {
            builder.append("\t").append("isComplex = ").append(attr.isComplex()).append(" children = ").append(VString.NEW_LINE);
            final List<HMetaField> children = attr.children();
            children.forEach(field -> {
                builder.append("\t\t").append(VString.LEFT_BRACKET).append(field.name())
                    .append(",").append(field.alias()).append(VString.RIGHT_BRACKET).append(VString.COMMA);
                builder.append(" type=").append(attr.type()).append(VString.NEW_LINE);
            });
        }

        // Reference
        if (Objects.nonNull(reference)) {
            builder.append("\t").append(reference).append(VString.NEW_LINE);
        }
        builder.append(":::----------------" + VString.NEW_LINE);
        return builder.toString();
    }
}
