package io.zerows.epoch.store.jooq;

import io.r2mo.typed.common.Kv;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.zerows.epoch.basicore.MDConnect;
import io.zerows.epoch.constant.KName;
import io.zerows.epoch.database.cp.DataPool;
import io.zerows.epoch.database.jooq.operation.DBJoin;
import io.zerows.epoch.database.jooq.operation.DBJooq;
import io.zerows.platform.constant.VValue;
import io.zerows.support.Ut;

import java.util.Objects;

public class DB {
    /**
     * Get reference of UxJooq that bind to Dao class, this method access standard database,
     * the configured position is `vertx-jooq.yml`
     * <p>
     * key = provider
     *
     * <pre><code>
     * jooq:
     *   provider:
     *     driverClassName: "com.mysql.cj.jdbc.Driver"
     * </code></pre>
     *
     * @param clazz The class of `VertxDao` that has been generated by jooq tool
     *
     * @return UxJooq reference that has been initialized
     */
    public static DBJooq on(final Class<?> clazz) {
        return DBJooq.of(clazz);
    }

    /**
     * The overloading method of above `join(Class<?>)` method here.
     *
     * @param clazz The class of `VertxDao` that has been generated by jooq tool
     * @param key   the key configuration in vertx-jooq.yml such as above "orbit", "provider"
     *
     * @return UxJooq reference that has been initialized
     */
    public static DBJooq on(final Class<?> clazz, final String key) {
        return DBJooq.of(clazz, key);
    }

    /**
     * 专用于新配置下的提取 UxJooq 的方法
     *
     * @param connect 连接配置，对应 model/connect.yml
     *
     * @return 返回引用对象
     */
    public static DBJooq bridge(final MDConnect connect) {
        final Class<?> daoCls = connect.getDao();
        Objects.requireNonNull(daoCls);
        // Pojo with
        final String pojoFile = connect.getPojoFile();
        if (Ut.isNil(pojoFile)) {
            return on(daoCls);
        } else {
            return on(daoCls).on(pojoFile);
        }
    }


    /**
     * The overloading method of above `join(Class<?>)` method here.
     *
     * @param clazz The class of `VertxDao` that has been generated by jooq tool
     * @param pool  Input data pool reference, it provide developers to access other database in one application.
     *
     * @return UxJooq reference that has been initialized
     */
    @Deprecated
    public static DBJooq on(final Class<?> clazz, final DataPool pool) {
        return DBJooq.of(clazz, pool);
    }


    public static DBJoin bridge(final MDConnect active, final MDConnect standBy,
                                final Kv<String, String> fieldJoin, final JsonObject aliasJ) {
        final DBJoin join = DBJoin.of(null);
        final String pojoActive = active.getPojoFile();
        if (Ut.isNotNil(pojoActive)) {
            join.pojo(active.getDao(), pojoActive);
        }
        final String pojoStandBy = standBy.getPojoFile();
        if (Ut.isNotNil(pojoStandBy)) {
            join.pojo(standBy.getDao(), pojoStandBy);
        }
        final String fieldActive = Ut.isNotNil(fieldJoin.key()) ? fieldJoin.key() : KName.KEY;
        final String fieldStandBy = Ut.isNotNil(fieldJoin.value()) ? fieldJoin.value() : KName.KEY;

        join.add(active.getDao(), fieldActive).join(standBy.getDao(), fieldStandBy);

        return bridgeAlias(join, active, standBy, aliasJ);
    }

    public static DBJoin bridge(final MDConnect active, final MDConnect standBy,
                                final Kv<String, String> fieldJoin) {
        return bridge(active, standBy, fieldJoin, null);
    }

    /**
     * alias 的数据结构如
     * <pre><code>
     *     "alias": {
     *          "{TABLE1}": [
     *              field1,
     *              field2,
     *          ],
     *          "{TABLE2}": [
     *              field1,
     *              field2
     *          ]
     *     }
     * </code></pre>
     *
     * @param join
     * @param active
     * @param standBy
     * @param aliasJ
     */
    public static DBJoin bridgeAlias(final DBJoin join, final MDConnect active, final MDConnect standBy, final JsonObject aliasJ) {
        if (Ut.isNil(aliasJ)) {
            return join;
        }
        Ut.<JsonArray>itJObject(aliasJ).forEach(entry -> {
            final JsonArray fields = entry.getValue();
            if (2 == fields.size()) {
                final String tableName = entry.getKey();
                final Class<?> daoCls;
                if (tableName.equals(active.getTable())) {
                    daoCls = active.getDao();
                } else if (tableName.equals(standBy.getTable())) {
                    daoCls = standBy.getDao();
                } else {
                    Ut.Log.database(DBJoin.class).error("( Join ) Please check your table name: {}", tableName);
                    daoCls = null;
                }
                final String fieldKey = fields.getString(VValue.IDX);
                final String fieldJoin = fields.getString(VValue.ONE);
                join.alias(daoCls, fieldKey, fieldJoin);
            } else {
                Ut.Log.database(DBJoin.class).error("( Join ) Please check your alias configuration: {}", fields);
            }
        });
        return join;
    }

    public static DBJoin join(final String configFile) {
        return DBJoin.of(configFile);
    }

    public static DBJoin join() {
        return DBJoin.of(null);
    }

    public static DBJoin join(final Class<?> daoCls) {
        return DBJoin.of(null).add(daoCls);
    }
}
